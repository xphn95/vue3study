# 记录Vue使用中关键的知识点



## 当有很多属性需要传递给子组件时, 可以使用 `v-bind:对象名` 的形式来传递.

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <div id="root">
    <!-- 1. 传整个对象 -->
    <!-- 3. 绑定的属性不支持驼峰 -->
    <test v-bind='params' :content-abc="content"></test>
  </div>
  <script>
    const test = {
      template:  `
        <div>{{a}}-{{b}}-{{c}}-{{d}}-{{contentAbc}}</div>
      `,
      // 2. 接收传递的参数时把属性分解开
      // 4. 短横线形式的属性接收时要写成驼峰形式
      props: {
        a: Number,
        b: Number,
        c: Number,
        d: Number,
        contentAbc: Number
      }
    }
    const { createApp } = Vue
    const app = createApp({
      data() {
        return {
          params: {
            a: 123,
            b: 456,
            c: 789,
            d: 135
          },
          content: 246
        }
      },
      components: {
        test
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



## Non-Props属性

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
  <style>
    p {
      color: orange;
    }
  </style>
</head>
<body>
  <div id="root">
    <msg msg1="msg1" msg2="msg2"></msg>
  </div>
  <script>
    const msg = {
      // 这个属性设置成 false 没有明确接收的传值不会默认作为标签属性
      // inheritAttrs: false,
      template: `
        <p>v-bind="$attrs"可以拿到全部属性</p>
        <div v-bind="$attrs">{{$attrs}}</div>
        <p>:想要绑定的属性名="$attrs.属性名"可以拿到指定的属性</p>
        <div :msg="$attrs.msg1">{{$attrs.msg1}}</div>
        <div :msg="$attrs.msg2">{{this.$attrs.msg2}}</div>
      `
    }
    const { createApp } = Vue
    const app = createApp({
      components: {
        msg
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



## 父子组件传值的常规使用

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
  <style>
    * {
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="root">
    <counter :count="count" @add-one="handleAddOne"></counter>
  </div>
  <script>
    const counter = {
      template: `<div @click="addOne">{{count}}</div>`,
      props: {
        count: Number
      },
      methods: {
        addOne() {
          this.$emit('addOne', 2)
        }
      }
    }
    const { createApp } = Vue
    const app = createApp({
      components: {
        counter
      },
      data() {
        return {
          count: 1
        }
      },
      methods: {
        handleAddOne(inc) {
          this.count += inc
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



## 当父子组件的通信类似于值的双向绑定时, 有个简化的写法

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
  <style>
    * {
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="root">
    <!-- <counter v-model="num"></counter> -->
    <!-- 自己起别名 v-model:别名 -->
    <counter v-model:count="num"></counter>
  </div>
  <script>
    const counter = {
      /* template: `
        <div @click="handleClick(5)">{{modelValue}}</div>
      `, */
      template: `
        <div @click="handleClick(5)">{{count}}</div>
      `,
      props: {
        // 这是默认的
        // modelValue: Number
        // 可以用自己写的别名
        count: Number
      },
      methods: {
        handleClick(inc) {
          // this.$emit('update:modelValue', this.modelValue + inc)
          this.$emit('update:count', this.count + inc)
        }
      }
    }
    const { createApp } = Vue
    const app = createApp({
      components: {
        counter
      },
      data() {
        return {
          num: 1
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



## 组件使用 v-model 的自定义修饰符

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
  <style>
    div {
      font-size: 40px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="root">
    <!-- 使用自定义修饰符 -->
    <counter v-model.captalize="num"></counter>
  </div>
  <script>
    const counter = {
      template: `
        <div @click="handleClick('b')">{{modelValue}}</div>
      `,
      props: {
        modelValue: String,
        // 默认是空对象, 如果使用了修饰符, 就是 { 修饰符: true }
        modelModifiers: {
          default: () => ({})
        }
      },
      mounted() {
        console.log(this.modelModifiers)
      },
      methods: {
        handleClick(str) {
          let newState = this.modelValue + str
          // 判断是否使用了修饰符
          if (this.modelModifiers.captalize) {
            newState = newState.toUpperCase()
          }
          this.$emit('update:modelValue', newState)
        }
      }
    }
    const { createApp } = Vue
    const app = createApp({
      components: {
        counter
      },
      data() {
        return {
          num: 'a'
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



## 插槽的使用

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <div id="root">
    <!-- 这里注意 DOM 中组件不能写成自闭合的形式 -->
    <!-- 这里尝试写成自闭合, 组件就出现不能复用的效果 -->
    <!-- 父模板里调用的数据是父组件的数据 -->
    <!-- 子模板里调用的数据是子组件的数据 -->
    <myform>
      <button>{{text}}</button>
    </myform>
    <myform>
      <div>{{text}}</div>
    </myform>
    <myform></myform>
  </div>
  <script>
    const myform = {
      // 使用插槽是无法绑定事件的
      // 解决办法是给 slot 包裹一个 span 标签绑定上事件
      // slot 里面包裹的内容就是父组件不传东西时的默认值
      template: `
        <div>
          <input />
          <span @click="handleClick">
            <slot>
              <button>default value</button>
            </slot>
          </span>
        </div>
      `,
      methods: {
        handleClick() {
          alert(123)
        }
      }
    }
    const { createApp } = Vue
    const app = createApp({
      /* template: `
        <my-component/>
        <my-component/>
        <my-component/>
      `, */
      components: {
        myform
      },
      data() {
        return {
          text: '提交'
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```





## 具名插槽

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <div id="root">
    <layout>
      <!-- v-slot:xxx 要使用在 template 上, 可简写为 #xxx -->
      <template #header>
        <div>header</div>
      </template>
      <template #footer>
        <div>footer</div>
      </template>
    </layout>
  </div>
  <template id="layout">
    <!-- name 来指定名称与 v-slot 对应 -->
    <slot name="header"></slot>
    <div>content</div>
    <slot name="footer"></slot>
  </template>
  <script>
    const layout = {
      template: '#layout'
    }
    const { createApp } = Vue
    const app = createApp({
      components: {
        layout
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```





## 作用域插槽

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <div id="root">
    <!-- v-slot= 是接受子组件传递过来的值 -->
    <list v-slot="{item}">
      <div>{{item}}</div>
    </list>
  </div>
  <template id="list">
    <slot v-for="item of arr" :key="item" :item="item"/>
  </template>
  <script>
    const list = {
      template: '#list',
      data() {
        return {
          arr: [1, 2, 3]
        }
      }
    }
    const { createApp } = Vue
    const app = createApp({
      components: {
        list
      }
    })
    app.mount("#root")
  </script>
</body>
</html>
```



## 动态组件和异步组件

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
</head>
<body>
  <div id="root"></div>

  <template id="asyncCommonItem">
    <div>this is an async component</div>
  </template>

  <template id="rootTemplate">
    <!-- 动态组件 -->
    <!-- <keep-alive>
      <component :is="currentItem"></component>
    </keep-alive> -->

    <!-- 异步组件 -->
    <async-common-item></async-common-item>

    <button @click="handleClick" style="display: block">切换</button>
  </template>

  <script>
    const { createApp, defineAsyncComponent } = Vue
    const asyncCommonItem = defineAsyncComponent(() => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve({
            template: '#asyncCommonItem'
          })
        }, 4000)
      })
    })
    const app = createApp({
      template: '#rootTemplate',
      data() {
        return {
          currentItem: 'input-item'
        }
      },
      methods: {
        handleClick() {
          if(this.currentItem === 'input-item') {
            this.currentItem = 'common-item'
          } else {
            this.currentItem = 'input-item'
          }
        }
      }
    })
    app.component('input-item', {
      template: `<input/>`
    })
    app.component('common-item', {
      template: `<div>hello world</div>`
    })
    app.component('async-common-item', asyncCommonItem)
    app.mount('#root')
  </script>
</body>
</html>
```



## 基础知识补充

v-once: *让某个元素只渲染一次*

ref: *用来获取节点的语法, 或者用来调用子组件的方法*

provide/inject: *provide和inject可以实现向后代组件传值, 但是不是响应式的*

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="http://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <!-- provide和inject可以实现向后代组件传值, 但是不是响应式的 -->
  <div id="root"></div>

  <template id="app">
    <child></child>
    <button @click="count += 1">add</button>
  </template>

  <template id="child">
    <p>hello</p>
    <grandson></grandson>
  </template>

  <template id="grandson">
    <div>{{count}}</div>
  </template>
  <script>
    const { createApp } = Vue
    const app = createApp({
      template: "#app",
      data() {
        return {
          count: 5
        }
      },
      provide() {
        return {
          count: this.count
        }
      }
    })

    app.component('child', {
      template: "#child",
    })

    app.component('grandson', {
      template: "#grandson",
      inject: ['count']
    })
    const vm = app.mount('#root')
  </script>
</body>
</html>
```



## 过渡和动画

基础的使用就是动态绑定类或者行内样式

### 单组件的过渡和动画

使用 `<transition></transition>` 包裹, 结合它提供的类名

- v-enter-from
- v-enter-active
- v-enter-to
- v-leave-from
- v-leave-active
- v-leave-to

可以自定义

如: `<transition name="my"></transition>`,

- my-enter-from
- my-enter-active
- my-enter-to
- my-leave-from
- my-leave-active
- my-leave-to

### 结合动画库

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />
  <title>Document</title>
</head>
<body>
  <div id="root"></div>

  <template id="app">
    <transition
      enter-active-class="animate__animated animate__bounce"
      leave-active-class="animate__animated animate__backOutDown"
    >
      <div v-show="isShow">hello</div>
    </transition>
    <button @click="handleClick">切换</button>
  </template>

  <script>
    const { createApp } = Vue
    const app = createApp({
      template: '#app',
      data() {
        return {
          isShow: false
        }
      },
      methods: {
        handleClick() {
          this.isShow = !this.isShow
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```

也就是完全自定义类名

### transition 的 type 属性

当过渡和动画同时存在, 指定 "transition" 或 "animation" 以哪个时间为准

### transition 的 :duration 属性

可以忽略 css 中的过渡和动画的时间, 以这个属性指定的时间为准

例如: `<transtion :duration="3000"></transtion>`

也可以接受对象, 分别指定入场和出场的时间

例如: `<transition :duration="{enter: 2000, leave: 3000}"></transition>`

### transition 的 :css 属性

可以使用或屏蔽来自 css 设置的过渡和动画效果

### 钩子

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>

  <template id="app">
    <transition
      @before-enter="handleBeforeEnter"
      @enter="handleEnterActive"
      @after-enter="handleAfterEnter"
      @before-leave="handleBeforeLeave"
      @leave="handleLeaveActive"
      @after-leave="handleAfterLeave"
    >
      <div v-show="isShow">hello</div>
    </transition>
    <button @click="handleClick">切换</button>
  </template>

  <script>
    const { createApp } = Vue
    const app = createApp({
      template: '#app',
      data() {
        return {
          isShow: false
        }
      },
      methods: {
        handleClick() {
          this.isShow = !this.isShow
        },
        handleBeforeEnter(el) {
          el.style.color = 'pink'
        },
        handleEnterActive(el, done) {
          const id = setInterval(() => {
            if (el.style.color === 'pink') {
              el.style.color = 'green'
            } else {
              el.style.color = 'pink'
            }
          }, 1000)
          setTimeout(() => {
            clearInterval(id)
            done() // 感觉用途是把执行权交给下一个钩子
          }, 3000)
        },
        handleAfterEnter() {
          console.log(123)
        },
        handleBeforeLeave(el) {
          el.style.fontSize = '20px'
        },
        handleLeaveActive(el, done) {
          const id = setInterval(() => {
            if (el.style.color === 'green') {
              el.style.color = '#c44569'
            } else {
              el.style.color = 'green'
            }
          }, 1000)
          setTimeout(() => {
            clearInterval(id)
            done()
          }, 3000)
        },
        handleAfterLeave() {
          console.log('done')
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



### 多组件切换(mode属性)

- out-in: 先隐藏后显示
- in-out: 先显示后隐藏

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://unpkg.com/vue@next"></script>
  <style>
    .v-enter-from, .v-leave-to {
      opacity: 0;
    }
    .v-enter-active, .v-leave-active {
      transition: opacity 3s ease-out;
    }
    .v-enter-to, .v-leave-from {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <template id="app">
    <transition mode="out-in">
      <div v-if="isShow">hello</div>
      <div v-else>bye</div>
    </transition>
    <button @click="handleClick">切换</button>
  </template>

  <script>
    const { createApp } = Vue
    const app = createApp({
      template: '#app',
      data() {
        return {
          isShow: true
        }
      },
      methods: {
        handleClick() {
          this.isShow = !this.isShow
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



### appear 属性

`<transition appear></transition>` 添加这个属性首次加载时会有入场效果.



### 列表动画

使用 `<transition-group></transition-group>` 包裹.

多了 `.v-move` 类, 用来处理已存在的 item 的动画.

注意 item 得是行内块元素或者块元素.



## Mixin 混入语法(3.x之后不建议使用了, 不好定位问题, 不方便维护)

- 组件的 data/methods 优先级高于 mixin 的 data/methods 优先级.
- 生命周期函数, 先执行 mixin 里面的, 再执行组件里面的.
- 组件的<font style="color: red">自定义属性</font>优先级高于 mixin 的<font style="color: red">自定义属性</font>优先级.



```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div>{{this.$options.number}}</div>
  </template>
  <script>
    const myMixin = {
      number: 2
    }
    const { createApp } = Vue
    const app = createApp({
      template: "#app",
      number: 1,
      mixins: [myMixin]
    })
    // 改变选项的混合策略
    app.config.optionMergeStrategies.number = (mixinVal, appVal) => {
      return mixinVal || appVal
    }
    app.mount('#root')
  </script>
</body>
</html>
```



## 自定义指令



### 全局/局部自定义指令及生命周期



```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>

  <template id="app">
    <input type="text" v-focus v-if="isShow">
    <button @click="isShow = !isShow">显示/隐藏</button>
  </template>
  <script>
    // 局部注册自定义指令
    const directives = {
      focus: {
        beforeMount(el) {
          console.log(el, 'beforeMount')
        },
        mounted(el) {
          el.focus()
          console.log('mounted')
        },
        beforeUpdate() {
          console.log('beforeUpdate')
        },
        updated() {
          console.log('updated')
        },
        beforeUnmount() {
          console.log('beforeUnmount')
        },
        unmounted() {
          console.log('mounted')
        }
      }
    }
    const { createApp } = Vue
    const app = createApp({
      template: '#app',
      directives,
      data() {
        return {
          isShow: false
        }
      }
      /* mounted() {
        this.$refs.input.focus()
      } */
    })
    // 全局注册自定义指令
    /* app.directive('focus', {
      mounted(el) {
        el.focus()
      }
    }) */
    app.mount('#root')
  </script>
</body>
</html>
```



### 案例和函数简写

[函数简写](https://v3.cn.vuejs.org/guide/custom-directive.html#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99)

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
  <style>
    .header {
      position: absolute;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div class="header" v-pos:abc="this.top">
      <input type="text">
      <button @click="moveTop">下移</button>
    </div>
  </template>
  <script>
    const directives = {
      /* pos: {
        mounted(el, binding) {
          el.style.top = `${binding.value}px`
        },
        updated(el, binding) {
          el.style.top = `${binding.value}px`
        }
      } */
      // 如果 mounted 和 updated 行为一致, 可以简写为一个函数
      // 文档: https://v3.cn.vuejs.org/guide/custom-directive.html#%E5%87%BD%E6%95%B0%E7%AE%80%E5%86%99
      pos: (el, binding) => {
        console.log(binding.arg)
        el.style.top = `${binding.value}px`
      }
    }
    const { createApp } = Vue
    const app = createApp({
      template: '#app',
      directives,
      data() {
        return {
          top: 10
        }
      },
      methods: {
        moveTop() {
          this.top += 10
        }
      }
    })
    app.mount('#root')
  </script>
</body>
</html>
```



## 传送门

使用 `teleport` 包裹, 就可以把里面得元素挂载到目标元素上

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
  <style>
    .area {
      position: absolute;
      width: 200px;
      height: 300px;
      background-color: #eaeaea;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    .mask {
      position: absolute;
      top: 0;
      bottom: 10px;
      left: 0;
      right: 0;
      background-color: pink;
      opacity: .6;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div class="area">
      <button @click="isShow = !isShow">按钮</button>
      <teleport to='body'>
        <div class="mask" v-show="isShow"></div>
      </teleport>
    </div>
  </template>

  <script>
    const root = {
      template: '#app',
      data() {
        return {
          isShow: false
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



## render 函数



```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <!-- 根组件 -->
  <template id="app">
    <hello :level="1">hello~</hello>
  </template>
  <!-- 子组件 -->
  <template id="hello">
    <h1 v-if="level === 1">
      <slot></slot>
    </h1>
    <h2 v-if="level === 2">
      <slot></slot>
    </h2>
    <h3 v-if="level === 3">
      <slot></slot>
    </h3>
    <h4 v-if="level === 4">
      <slot></slot>
    </h4>
    <h5 v-if="level === 5">
      <slot></slot>
    </h5>
    <h6 v-if="level === 6">
      <slot></slot>
    </h6>
  </template>
  <script>
    // template -> 解析成 render 函数 -> 调用 h 函数 -> 生成虚拟 DOM (js对象) -> 真实 DOM -> 渲染到页面上
    const hello = {
      // template: '#hello',
      props: {
        level: {
          type: Number,
          default: 6
        }
      },
      render() {
        const { h } = Vue
        return h(`h${this.level}`, {}, this.$slots.default())
      }
    }
    const root = {
      template: '#app',
      components: {
        hello
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



## 插件



### 基本使用

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <my-title></my-title>
  </template>
  <template id="myTitle">
    <div>
      <span>{{name}}</span>
      <input type="text" v-focus>
    </div>
  </template>
  <script>
    // 定义插件
    const myPlugin = {
      install(app, options) {
        // console.log(app, options)
        app.provide('name', 'mike')
        app.directive('focus', {
          mounted(el) {
            el.focus()
            el.value = 'test'
          }
        })
        app.mixin({
          mounted() {
            console.log('mixin')
          }
        })
        // 全局属性配置
        app.config.globalProperties.$sayHello = () => {
          console.log('hi world')
        }
      }
    }
    // 子组件
    const myTitle = {
      template: '#myTitle',
      inject: ['name'],
      mounted() {
        this.$sayHello()
      }
    }
    // 根组件
    const root = {
      template: '#app',
      components: {
        myTitle
      }
    }
    const app = Vue.createApp(root)
    app.use(myPlugin)
    app.mount('#root')
  </script>
</body>
</html>
```



## setup 函数的使用

setup 的执行时机比 beforeCreate 还要早. 所以函数内部的 this 没有指向实例.                

返回的变量可以直接在模板中使用, 可代替 data.

### ref 和 reactive

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <!-- <div>{{name}}</div> -->
    <div>{{nameobj.name}}</div>
  </template>
  <script>
    // ref, reactive 响应式的引用
    // 原理, 通过 proxy 对数据进行封装, 等数据变化时, 触发模板等内容的更新
    // ref 处理基础类型的数据
    // reactive 处理非基础类型的数据
    const { ref, reactive } = Vue
    const root = {
      template: '#app',
      setup() {
        // proxy, 'genji' 变成 proxy({value: 'genji'}) 这样的一个响应式引用
        /* let name = ref('genji')
        setTimeout(() => {
          name.value = 'McCree'
          console.log(name)
        }, 2000) */
        const nameobj = reactive({
          name: 'genji'
        })

        setTimeout(() => {
          nameobj.name = 'McCree'
        }, 2000)
        return {
          nameobj
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### readonly 和 toRefs 的使用

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div>{{nameobj.name}}</div>
    <div>{{name}}</div>
  </template>

  <script>
    const { ref, reactive, readonly, toRefs } = Vue
    const root = {
      template: '#app',
      setup() {
        const nameobj = reactive({name: 'genji'})
        const copyNameobj = readonly(nameobj)
        setTimeout(() => {
          nameobj.name = 'McCree'
          copyNameobj.name = 'Ashe' // 会报警告, 无法修改只读的, 但仍然是响应式的
        }, 2000)
        // toRefs 会做一个转换
        // proxy({name: 'genji'}) -> {name: proxy({value: 'genji'})}
        const { name } = toRefs(copyNameobj)
        return {
          nameobj,
          name
        }
      },
      mounted() {
        console.log(this.name)
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### toRef 和 context 的使用

toRef

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div>{{name}}</div>
    <div>{{age}}</div>
  </template>
  <script>
    const root = {
      template: '#app',
      setup() {
        const { reactive, toRefs, toRef } = Vue
        const data = reactive({
          name: 'ashe'
        })
        const { name } = toRefs(data)
        // 对不存在的数据会设置为默认的值为 undefined 的响应式数据
        const age = toRef(data, 'age')
        setTimeout(() => {
          // console.log(age)
          name.value = 'Dva'
          age.value = 20
        }, 2000)
        return {
          name,
          age
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



context

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
  <style>
    * {
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <!-- <child test="test"> -->
    <child @listen-click="childClick">
      <p>slot text</p>
    </child>
  </template>
  <template id="child">
    <div @click="handleClick">{{data.name}}</div>
    <!-- <slot></slot> -->
  </template>
  <script>
    const child = {
      template: '#child',
      setup(props, context) {
        const { reactive, h } = Vue
        const { attrs, slots, emit } = context
        console.log(attrs.test) // 接收父组件传递的 None-props 属性(就是子组件没有接收的属性)
        console.log(slots.default()) // 接收父组件传递的插槽
        const data = reactive({
          name: 'ashe'
        })
        // 子组件的点击事件
        function handleClick () {
          // 触发父组件的同名事件
          emit('listen-click')
        }
        return {
          data,
          handleClick
        }
        /* return () => h('div', {}, [h('div', {}, data.name), slots.default()]) */
      }
    }
    const root = {
      template: '#app',
      components: {
        child
      },
      setup() {
        // 定义子组件的事件方法
        function childClick() {
          console.log('child click')
        }
        return {
          childClick
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### composition api 中的计算属性

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <input type="text" :value="msg" @input="handleInput">
    <div>{{hiMsg}}</div>
  </template>
  <script>
    const root = {
      template: '#app',
      setup(props) {
        const { ref, computed } = Vue
        const msg = ref('hello')
        const handleInput = (e) => {
          msg.value = e.target.value
        }
        // 使用 computed 包裹一个箭头函数返回计算值即可
        // 这是简单的用法
        /* const hiMsg = computed(() => {
          // console.log(msg.value)
          return `hello, ${msg.value}`
        }) */
        let hiMsg = computed({
          get() {
            return `hello, ${msg.value}`
          },
          set(newValue) {
            return msg.value = newValue
          }
        })
        setTimeout(() => {
          hiMsg.value = 'new value'
        }, 3000)
        return {
          msg,
          handleInput,
          hiMsg
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### watch

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <input type="text" v-model="msg">
    <div>{{msg}}</div>
    <input type="text" v-model="obj.name">
    <div>{{obj.name}}</div>
    <input type="text" v-model="obj.lastName">
    <div>{{fullName}}</div>
  </template>
  <script>
    const root = {
      template: '#app',
      setup(props) {
        const { ref, reactive, watch } = Vue
        const msg = ref('hello!!')
        const fullName = ref('')
        const obj = reactive({
          name: 'mike',
          lastName: 'brown',
          age: 20
        })
        // 具备惰性
        watch(msg, (newValue, oldValue) => {
          console.log(newValue, oldValue)
        })
        // 监听的如果是对象的属性要写成函数形式
        watch(() => obj.name, (newValue, oldValue) => {
          console.log(newValue, oldValue)
        })
        // 监听多个数据
        watch([() => obj.name, () => obj.lastName], ([newName, newLastName], [oldName, oldLastName]) => {
          fullName.value = `${newName} ${newLastName}`
        })
        return {
          msg,
          obj,
          fullName
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### watchEffect

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>watchEffect</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <input type="text" v-model="msg">
    <div>{{msg}}</div>
  </template>
  <script>
    const { watchEffect } = Vue
    const root = {
      template: '#app',
      setup(props) {
        const { ref, watch, watchEffect } = Vue
        const msg = ref('hello')
        const stop = watch(msg, (newMsg, oldMsg) => {
          msg.value = newMsg
          console.log(newMsg)
        }, {
          immediate: true
        })
        /* const stopEffect = watchEffect(() => {
          console.log(msg.value)
        }) */
        setTimeout(() => {
          console.log('stop')
          // stopEffect()
          stop()
        }, 5000)
        return {
          msg
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### watch 和 watchEffect 的区别

|                    |      watch       | watchEffect |
| ------------------ | :--------------: | :---------: |
| 惰性               | 有(也可立即执行) |     无      |
| 获取当前值和原始值 |       可以       |   不可以    |
| 指定监听内容       |       需要       |   不需要    |
| 手动取消监听       |       可以       |    可以     |



### 生命周期

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <!-- <div v-if="isShow">{{count}}</div> -->
    <child v-if="isShow" :count="count"></child>
    <button @click="handleAdd">自增</button>
    <button @click="handleClick">切换</button>
  </template>
  <template id="child">
    <div>{{count}}</div>
  </template>
  <script>
    const {
      onBeforeMount,
      onMounted,
      onBeforeUpdate,
      onUpdated,
      onBeforeUnmount,
      onUnmounted,
      ref,
      toRefs
    } = Vue
    const child = {
      template: '#child',
      props: {
        count: Number
      },
      setup(props) {
        let { count } = toRefs(props)
        onBeforeUnmount(() => {
          console.log('onBeforeUnmount')
        })
        onUnmounted(() => {
          console.log('onUnmounted')
        })
        return {
          count
        }
      }
    }
    const root = {
      template: '#app',
      components: {
        child
      },
      setup(props) {
        onBeforeMount(() => {
          console.log('onBeforeMount')
        })
        onMounted(() => {
          console.log('onMounted')
        })
        onBeforeUpdate(() => {
          console.log('onBeforeUpdate')
        })
        onUpdated(() => {
          console.log('onUpdated')
        })
        onBeforeUnmount(() => {
          console.log('onBeforeUnmount')
        })
        onUnmounted(() => {
          console.log('onUnmounted')
        })
        const isShow = ref(true)
        let count = ref(0)
        const handleClick = () => {
          isShow.value = !isShow.value
        }
        const handleAdd = () => {
          count.value += 1
        }
        return {
          isShow,
          count,
          handleAdd,
          handleClick
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div @click="handleClick(count)">{{count.value}}</div>
    <div @click="handleClick(count1)">{{count1.value}}</div>
  </template>
  <script>
    const root = {
      template: '#app',
      setup(props) {
        const {
          onRenderTracked,
          onRenderTriggered,
          ref,
          reactive
        } = Vue
        const count = reactive({value: 0})
        const count1 = reactive({value: 1})
        const handleClick = (num) => {
          console.log(num)
          num.value += 1
        }
        // 跟踪所有 return 的值, 前提是组件发生更新
        onRenderTracked(({target, key, type}) => {
          console.log(target, key, type)
        })
        // 精确跟踪变化值
        onRenderTriggered(({target, key, type}) => {
          console.log(target, key, type)
        })
        return {
          count,
          count1,
          handleClick
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### setup 中的 provide 和 inject



注意这个传值是一次性的, 并非响应式的, 如何希望实现响应式的效果应该借助 `计算属性` .

但是一定要注意和计算属性的配合次序, provide 只能用在 setup 中, 有想到在计算属性中用更新触发 provide, 但肯定是不行的, 回调函数就脱离了 setup, 只能在 provide 的第二个参数使用计算属性实现.

传值要符合单向数据流的思想, 最好使用 readonly 确保子组件不会修改传过来的值. 若想修改祖先组件的状态, 可以借助 react 中的方法下放的思想, 把修改状态的方法传给后代组件.

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <son></son>
  </template>
  <template id="son">
    <grandson></grandson>
  </template>
  <template id="grandson">
    <div>{{people}}</div>
    <button @click="modifyName">修改</button>
    <button @click="modifyNamePro('McCree')">修改(祖先组件)</button>
  </template>
  <script>
    const grandson = {
      template: '#grandson',
      setup() {
        const {
          inject,
          onMounted,
          onUpdated,
          watchEffect
        } = Vue
        // 第二个参数不是必须的, 是默认值, 当祖先组件没有传这个参数时使用这个默认值
        const people = inject('objname', 'ashe')
        onMounted(() => {
          console.log(people.value)
        })
        // 这个修改是不成功的, 因为是只读的
        const modifyName = () => {
          people.value = 'Dva'
        }
        // 祖先组件提供的方法
        const modifyNamePro = inject('modifyNamePro')
        /* onMounted(() => {
          console.log(modifyNamePro)
        }) */
        watchEffect(() => {
          console.log(people.value)
        })
        return {
          people,
          modifyName,
          modifyNamePro
        }
      }
    }
    const son = {
      template: '#son',
      components: {
        grandson
      }
    }
    const root = {
      template: '#app',
      components: {
        son
      },
      setup(props) {
        const {
          reactive,
          provide,
          readonly,
          computed,
          watchEffect
        } = Vue
        const obj = reactive({
          name: 'mike'
        })
        watchEffect(() => {
          console.log(obj.name, 80)
        })
        /* setTimeout(() => {
          obj.name = 'genji'
          console.log('changed')
        }, 5000) */
        // 两个都是必须的, key 和 value
        // provide('objname', readonly(obj.name)) // 这种传值不是响应式的
        // 用 computed 计算属性可以跟踪变化
        provide('objname', readonly(computed(() => {
          return obj.name
        })))
        // 传递一个修改的函数
        const modifyNamePro = (newname) => {
          obj.name = newname
        }
        provide('modifyNamePro', modifyNamePro)
        return {}
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```



### setup 中获取 DOM

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/vue@next"></script>
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <template id="app">
    <div ref="hello">hello</div>
  </template>
  <script>
    const root = {
      template: '#app',
      setup() {
        const {
          ref,
          onMounted
        } = Vue
        // 要和 ref 属性同名, 固定的写法
        const hello = ref(null)
        onMounted(() => {
          console.log(hello.value.innerHTML)
        })
        return {
          // 一定要导出
          hello
        }
      }
    }
    const app = Vue.createApp(root)
    app.mount('#root')
  </script>
</body>
</html>
```

